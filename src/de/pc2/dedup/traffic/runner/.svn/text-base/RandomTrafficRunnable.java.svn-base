package de.pc2.dedup.traffic.runner;

import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.Future;

public class RandomTrafficRunnable extends TrafficRunnable {
	private final int startindex;
	private final int endindex;
	private volatile boolean finished = false;
	private volatile boolean successful = false;
	private volatile int blocksWritten = 0;
	private LinkedHashMap<Long, Integer> statistics = new LinkedHashMap<Long, Integer>();
	private long startTime = 0;

	public RandomTrafficRunnable(Traffic traffic, FileChannel channel,
			int startindex, int endindex) {
		super(traffic,channel);
		this.startindex = startindex;
		this.endindex = endindex;
	}

	public void preload() throws Exception {
		//System.out.println("Preloading");
		List<Future<Boolean> > futures = new LinkedList<Future<Boolean>>();
		for(int i = startindex; i < startindex + (getTraffic().getLoadBlocks() * getTraffic().getPreloadWindow()); i += getTraffic().getLoadBlocks()) {
			if(i >= getTraffic().getBlockCount()) {
				break;
			}
			Future<Boolean> f = getTraffic().loadBuffer(i);
			if(f != null) {
				futures.add(f);
			}
			// wait until end
			for(Future<Boolean> f2 : futures) {
				f2.get();
			}
			futures.clear();
		}
		//System.out.println("Preloading finished");
	}

	public void run() {
		try {
			this.startTime = System.currentTimeMillis();
			int blocks = 0;
			for (int i = startindex; i < endindex; i += blocks) {
				List<Integer> randomBlock = null;
				blocks = getTraffic().getLoadBlocks();
				if(i == startindex && i % getTraffic().getLoadBlocks() != 0) {
					blocks = i % getTraffic().getLoadBlocks();
				} 
				if(i + blocks > endindex) {
					blocks = endindex - i;
				}
				// next load block			
				//System.out.println("Next block: " + i + " - " + (i + blocks));
				randomBlock = new ArrayList<Integer>();
				for(int j = i; j < i + blocks; j++) {
					randomBlock.add(j);
				}
				//System.out.println("Shuffling");
				Collections.shuffle(randomBlock);
				//System.out.println("Start writing block");
				for(int k = 0; k < randomBlock.size(); k++) {
					int bi = randomBlock.get(k);
					//System.out.println("Writing block "  + bi);
					ByteBuffer block = getTraffic().getBuffer(bi);
					long pos = ((long)bi) * Traffic.BLOCK_SIZE;
					getChannel().write(block, pos);

					blocksWritten++;

					long t = (System.currentTimeMillis() - this.startTime) / (1000 * TrafficRunner.getStatisticGranularty());
					if(statistics.containsKey(t) == false) {
						statistics.put(t, 0);
					}
					statistics.put(t, statistics.get(t) + 1);

					getTraffic().clearBuffer(bi);
				}
			}
			successful = true;
		} catch (Exception e) {
			successful = false;
			e.printStackTrace();
		}
		finished = true;
	}

	public boolean isFinished() {
		return finished;
	}

	public boolean isSuccessful() {
		return successful;
	}

	public int getBlocksWritten() {
		return blocksWritten;
	}

	public LinkedHashMap<Long, Integer> getStatistics() {
		return this.statistics;
	}
}
